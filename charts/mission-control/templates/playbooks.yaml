{{- if .Values.playbooks}}
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/flanksource/duty/main/schema/openapi/playbook.schema.json
apiVersion: mission-control.flanksource.com/v1
kind: Playbook
metadata:
  name: clear-event-queue
spec:
  parameters:
    - name: max_age
      label: Max Age (days)
      default: '30'
    - name: last_max_attempt
      label: Reset attempts where last tried is before (days)
      default: '7'
  title: Clear Event Queue
  category: Mission Control
  description: Deletes old events and fully retried events
  actions:
    - name: Delete stale events
      sql:
        connection: "connection://{{ .Values.connectionName }}"
        driver: postgres
        query: >-
          DELETE FROM event_queue
          WHERE created_at < NOW() - INTERVAL '$(.params.max_age) day'
    - name: Reset attempts
      sql:
        connection: "connection://{{ .Values.connectionName }}"
        driver: postgres
        query: >-
          UPDATE event_queue SET attempts = 0
          WHERE attempts > 0 AND
          last_attempt < NOW() - INTERVAL '$(.params.last_max_attempt) day'
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/flanksource/duty/main/schema/openapi/playbook.schema.json
apiVersion: mission-control.flanksource.com/v1
kind: Playbook
metadata:
  name: run-canary
spec:
  icon: Canary
  title: Run Canary
  description: Runs the canary on a canary-checker pod with configurable log level
  category: Mission Control
  configs:
    - types:
        - MissionControl::Canary
  parameters:
    - name: logLevel
      label: Log Level
      default: "-vvvvvvvvv"
      type: list
      properties:
        options:
          - label: info
            value: -v
          - label: debug
            value: -vv
          - label: trace
            value: -vvvvvvvvv
  actions:
    - name: Exec
      exec:
        connections:
          fromConfigItem: $(.config.id)
        script: |
          kubectl exec -i deploy/canary-checker -- sh -c '/app/canary-checker run - --namespace $(.config.tags.namespace) $(.params.logLevel)' <<"END"
          $(.config.config | toYAML)
          END
---
# yaml-language-server: $schema=https://raw.githubusercontent.com/flanksource/duty/main/schema/openapi/playbook.schema.json
apiVersion: mission-control.flanksource.com/v1
kind: Playbook
metadata:
  name: vacuum-mission-control-tables
spec:
  icon: database
  title: Vacuum tables
  description: Vacuum mission control database tables to improve performance
  category: Mission Control
  actions:
    - name: Choose tables to vacuum
      sql:
        connection: "connection://{{ .Values.connectionName }}"
        driver: postgres
        query : |
          WITH params AS (
            SELECT
              100::bigint            AS min_tuples_sum,
              0.20::double precision AS high_dead_frac,
              0.30::double precision AS very_high_dead_frac,
              100000::bigint         AS many_dead_tuples,
              1000::bigint           AS some_dead_tuples,
              100 * 1024 * 1024::bigint AS large_table_bytes,
              1 * 1024 * 1024 * 1024::bigint AS big_impact_bytes,
              '7 days'::interval     AS recent_window,
              14::int                AS days_for_overdue,
              20::double precision   AS idx_bloat_free_pct_warn
          ),
          safe_stats AS (
            SELECT
              n.nspname                                AS schemaname,
              c.relname                                AS tablename,
              s.n_live_tup                             AS live_tuples,
              s.n_dead_tup                             AS dead_tuples,
              (s.n_live_tup + s.n_dead_tup)            AS tuples_sum,
              s.last_vacuum,
              s.last_autovacuum,
              s.last_analyze,
              s.last_autoanalyze,
              pg_total_relation_size(c.oid)            AS size_bytes,
              pg_size_pretty(pg_total_relation_size(c.oid)) AS table_size,
              CASE WHEN (s.n_live_tup + s.n_dead_tup) > 0
                   THEN (s.n_dead_tup::numeric * 100.0 / (s.n_live_tup + s.n_dead_tup)::numeric)
                   ELSE 0 END                           AS dead_pct,
              c.oid AS table_oid
            FROM pg_stat_all_tables s
            JOIN pg_class c      ON s.relid = c.oid
            JOIN pg_namespace n  ON c.relnamespace = n.oid
            WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
          ),
          vacuum_needs AS (
            SELECT
              ss.*,
              COALESCE(
                date_part('day', now() - GREATEST(COALESCE(last_vacuum, 'epoch'::timestamp),
                                                  COALESCE(last_autovacuum, 'epoch'::timestamp))),
                9999
              )::int AS days_since_vacuum,
              COALESCE(
                date_part('day', now() - GREATEST(COALESCE(last_analyze, 'epoch'::timestamp),
                                                  COALESCE(last_autoanalyze, 'epoch'::timestamp))),
                9999
              )::int AS days_since_analyze
            FROM safe_stats ss
            JOIN params p ON true
            WHERE ss.tuples_sum >= p.min_tuples_sum
          ),
          index_stats AS (
            SELECT
              i.indexrelid,
              i.indrelid,
              quote_ident(ns_idx.nspname) || '.' || quote_ident(ci.relname) AS index_fqn,
              ci.relname AS index_name,
              quote_ident(ns_tab.nspname) || '.' || quote_ident(t.relname) AS table_fqn,
              ci.oid AS index_oid,
              t.oid  AS table_oid,
              pg_relation_size(i.indexrelid) AS index_size_bytes,
              pg_size_pretty(pg_relation_size(i.indexrelid)) AS index_size,
              coalesce(ai.idx_scan,0) AS idx_scan,
              coalesce(ai.idx_tup_read,0) AS idx_tup_read,
              coalesce(ai.idx_tup_fetch,0) AS idx_tup_fetch
            FROM pg_index i
            JOIN pg_class ci        ON ci.oid = i.indexrelid
            JOIN pg_namespace ns_idx ON ns_idx.oid = ci.relnamespace
            JOIN pg_class t         ON t.oid = i.indrelid
            JOIN pg_namespace ns_tab ON ns_tab.oid = t.relnamespace
            LEFT JOIN pg_stat_all_indexes ai ON ai.indexrelid = i.indexrelid
            WHERE ci.relkind = 'i'
          )
          -- final output: only tables that need a vacuum action (conservative recommendations)
          SELECT
            vn.schemaname || '.' || vn.tablename AS table_name,
            vn.table_size,
            vn.size_bytes AS table_size_bytes,
            vn.live_tuples,
            vn.dead_tuples,
            ROUND(vn.dead_pct, 1)::text || '%' AS dead_percentage,
            vn.days_since_vacuum,
            vn.days_since_analyze,
            (LEAST(vn.dead_pct, 100)::double precision * 1.5
             + LN(GREATEST(vn.size_bytes,1)) / LN(1024) * 2
             + vn.days_since_vacuum * 0.5)::int AS urgency_score,
            -- vacuum recommendation (conservative)
            CASE
              WHEN vn.dead_pct >= params.very_high_dead_frac * 100 AND vn.size_bytes >= params.large_table_bytes THEN
                'REVIEW: Consider VACUUM FULL or RECLUSTER (HIGH dead%, large table)'
              WHEN vn.dead_pct >= params.very_high_dead_frac * 100 THEN
                'CONSIDER: VACUUM (ANALYZE) then assess for VACUUM FULL/REINDEX'
              WHEN vn.dead_pct >= params.high_dead_frac * 100 AND vn.dead_tuples >= params.some_dead_tuples THEN
                'VACUUM (VERBOSE, ANALYZE) recommended'
              WHEN vn.dead_tuples >= params.many_dead_tuples AND vn.days_since_vacuum > params.days_for_overdue THEN
                'VACUUM recommended (many dead tuples and overdue)'
              ELSE 'NO VACUUM NEEDED (monitor)'
            END AS vacuum_action,
            -- index summary (no pgstattuple)
            COUNT(ix.index_oid) FILTER (WHERE ix.index_oid IS NOT NULL) AS index_count,
            COALESCE(SUM(ix.index_size_bytes) FILTER (WHERE ix.index_oid IS NOT NULL),0) AS total_index_bytes,
            pg_size_pretty(COALESCE(SUM(ix.index_size_bytes) FILTER (WHERE ix.index_oid IS NOT NULL),0)) AS total_index_size,
            -- note about per-index bloat: pgstattuple not used here
            'NO pgstattuple: run pgstattuple manually on suspects for exact index bloat' AS index_health_note,
            -- conservative command suggestion
            CASE
              WHEN (CASE
                      WHEN vn.dead_pct >= params.very_high_dead_frac * 100 AND vn.size_bytes >= params.large_table_bytes THEN 1
                      WHEN vn.dead_pct >= params.very_high_dead_frac * 100 THEN 1
                      WHEN vn.dead_pct >= params.high_dead_frac * 100 AND vn.dead_tuples >= params.some_dead_tuples THEN 1
                      WHEN vn.dead_tuples >= params.many_dead_tuples AND vn.days_since_vacuum > params.days_for_overdue THEN 1
                      ELSE 0 END) = 1
              THEN 'VACUUM (VERBOSE, ANALYZE) ' || quote_ident(vn.schemaname) || '.' || quote_ident(vn.tablename) || ';'
              ELSE 'No immediate vacuum command'
            END AS command_to_run
          FROM vacuum_needs vn
          JOIN params ON true
          LEFT JOIN index_stats ix ON ix.table_oid = vn.table_oid
          GROUP BY
            vn.schemaname, vn.tablename, vn.table_size, vn.size_bytes, vn.live_tuples, vn.dead_tuples,
            vn.dead_pct, vn.days_since_vacuum, vn.days_since_analyze, vn.table_oid, vn.last_vacuum,
            vn.last_autovacuum, vn.last_analyze, vn.last_autoanalyze,
            params.very_high_dead_frac, params.large_table_bytes, params.high_dead_frac, params.some_dead_tuples,
            params.many_dead_tuples, params.days_for_overdue
          -- filter: only tables where vacuum_action requires action
          HAVING
            MAX(
              CASE
                WHEN vn.dead_pct >= params.very_high_dead_frac * 100 AND vn.size_bytes >= params.large_table_bytes THEN 1
                WHEN vn.dead_pct >= params.very_high_dead_frac * 100 THEN 1
                WHEN vn.dead_pct >= params.high_dead_frac * 100 AND vn.dead_tuples >= params.some_dead_tuples THEN 1
                WHEN vn.dead_tuples >= params.many_dead_tuples AND vn.days_since_vacuum > params.days_for_overdue THEN 1
                ELSE 0
              END
            ) = 1
          ORDER BY urgency_score DESC, total_index_bytes DESC, table_size_bytes DESC;

    - name: Vacuum
      if: getLastAction().result.count > 0
      sql:
        connection: "connection://{{ .Values.connectionName }}"
        driver: postgres
        query : |
          # gotemplate: left-delim=$[[ right-delim=]]
          VACUUM (FULL, ANALYZE) $[[ getLastAction.result.rows | jq `map(.table_name) | join(", ")` ]]

{{- end }}
