---
apiVersion: mission-control.flanksource.com/v1
kind: Connection
metadata:
  name: {{ .Values.connectionName }}
spec:
  postgres:
    database: 
      value: mission-control
    insecureTLS: true
    host: 
      value: postgres
    username:
      valueFrom:
        secretKeyRef:
          name: incident-commander-postgres
          key: POSTGRES_USER
    password:
      valueFrom:
        secretKeyRef:
          name: incident-commander-postgres
          key: POSTGRES_PASSWORD
---
apiVersion: canaries.flanksource.com/v1
kind: Topology
metadata:
  name: {{ .Values.topologyName }}
  labels:
    {{- include "mission-control.labels" . | nindent 4 }}
spec:
  icon: mission-control
  schedule: '@every 5m'
  type: Topology
  properties:
  - name: URL
    type: url
    configLookup:
      config:
        name: incident-manager-ui
        tags:
          app.kubernetes.io/instance: mission-control
          app.kubernetes.io/name: incident-manager-ui
        type: Kubernetes::Ingress
      display:
        javascript: config.spec.rules[0].host
  components:
  - components:
    - icon: group
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: |
              JSON.stringify(results.rows.map(function(r) {return {name: r.name}}))
          name: Team names query
          query: SELECT name FROM teams
          results: -1
      name: Teams
      type: lookup
    icon: incidents
    name: Incident Commander
    checks:
    - inline:
        http:
        - endpoint: http://mission-control:8080/health
          name: incident-commander-http-check
          responseCodes:
          - 200
        schedule: '@every 1m'
    properties:
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Incident count query
          query: SELECT count(*) FROM incidents WHERE (resolved IS NULL) OR (closed
            IS NULL)
          results: 1
      name: Incidents
    - name: Docs
      text: https://docs.flanksource.com
      type: url
    - configLookup:
        config:
          name: mission-control
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: mission-control
          type: Kubernetes::Deployment
        display:
          javascript: |
            config.spec.template.spec.containers[0]['image'].split(':')[1]
      headline: true
      name: Version
    selectors:
    - labelSelector: app.kubernetes.io/name=mission-control
    type: API
  - checks:
    - inline:
        http:
        - endpoint: http://canary-checker:8080/health
          name: canary-checker-http-check
          responseCodes:
          - 200
        schedule: '@every 1m'
    components:
    - name: Canaries
      icon: canary-checker
      checks:
        - inline:
            postgres:
              - query: |
                  WITH cte AS (
                    SELECT name, resource_id, resource_type, created_at, details, status, ROW_NUMBER() OVER (PARTITION by resource_id, name ORDER BY created_at DESC) AS rn
                    FROM job_history
                    WHERE
                      resource_id in (select id::text from canaries where deleted_at is null) AND
                      status NOT IN ('RUNNING', 'ABORTED') AND
                      resource_type = 'canary'
                  )
                  SELECT * FROM cte WHERE rn = 1;
                connection: "connection://{{ .Values.connectionName }}"
                name: CanarySync Check
                transform:
                  expr: |
                    results.rows.map(r, {
                      'name': r.name + ':' + r.resource_id,
                      'icon': 'canary-checker',
                      'message': r.created_at + ' | ' + r.details.toJSON(),
                      'description': r.details.toJSON(),
                      'pass': r.status=='SUCCESS',
                    }).toJSON()
    - forEach:
        properties:
        - name: Type
          text: SystemTemplate
      icon: k8s-customresourcedefinition
      checks:
        - inline:
            postgres:
              - query: |
                  WITH cte AS (
                    SELECT name, resource_id, resource_type, created_at, details, status, ROW_NUMBER() OVER (PARTITION by resource_id, name ORDER BY created_at DESC) AS rn
                    FROM job_history
                    WHERE
                      resource_id in (select id::text from topologies where deleted_at is null) AND
                      status NOT IN ('RUNNING', 'ABORTED') AND
                      resource_type = 'topology'
                  )
                  SELECT * FROM cte WHERE rn = 1;
                connection: "connection://{{ .Values.connectionName }}"
                name: TopologyChecks
                transform:
                  expr: |
                    results.rows.map(r, {
                      'name': r.name + ':' + r.resource_id,
                      'icon': 'traces',
                      'message': r.created_at + ' | ' + r.details.toJSON(),
                      'description': r.details.toJSON(),
                      'pass': r.status=='SUCCESS',
                    }).toJSON()
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            expr: |
              results.rows.map(r, {
                'name': r.name,
                'properties': [
                  { 'name': 'Last runtime', 'text': r.time_end != null ? string(r.time_end) : 'N/A' },
                  { 'name': 'Duration', 'text': r.duration_millis != null ? string(r.duration_millis) : 'N/A', 'unit': 'ms', 'headline': true},
                  { 'name': 'Success Count', 'value': r.success_count, 'headline': true},
                  { 'name': 'Error Count', 'value': r.error_count, 'headline': true},
                ],
              }).toJSON()
          name: Topologies count query
          query: |
            SELECT * FROM (
              SELECT
                ROW_NUMBER() OVER (PARTITION BY t.name ORDER BY time_end DESC) AS rn, t.name, jh.status, jh.success_count,
                jh.error_count, jh.duration_millis, jh.time_end
              FROM topologies t
              INNER JOIN job_history jh ON t.id::text = jh.resource_id) AS s WHERE rn = 1
          results: 1
      name: Topologies
      type: lookup
    icon: heart
    name: Canary Checker
    properties:
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Component count query
          query: SELECT count(*) FROM components WHERE deleted_at IS NULL
          results: 1
      name: Components
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Check count query
          query: SELECT count(*) FROM checks WHERE deleted_at IS NULL
          results: 1
      name: Checks
    - configLookup:
        config:
          name: canary-checker
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: canary-checker
          type: Kubernetes::Deployment
        display:
          javascript: |
            config.spec.template.spec.containers[0]['image'].split(':')[1]
      headline: true
      name: Version
    - name: Docs
      text: https://docs.flanksource.com/canary-checker/overview
      type: url
    selectors:
    - labelSelector: app.kubernetes.io/name=canary-checker
    type: API

  - name: Event Queue
    icon: switch
    properties:
      - name: Backlog
        lookup:
          postgres:
            - query: SELECT count(*) FROM event_queue
              connection: "connection://{{ .Values.connectionName }}"
              display:
                expr: results.rows[0].count
              test:
                expr: results.rows[0].count < 200
    checks:
      - inline:
          postgres:
            - query: SELECT distinct(name), count(*) FROM event_queue GROUP BY name
              connection: "connection://{{ .Values.connectionName }}"
              name: Event Queue Checks
              transformDeleteStrategy: MarkHealthy
              transform:
                expr: |
                  results.rows.map(r, {
                    'name': r.name,
                    'icon': 'switch',
                    'message': string(r.count) + ' items in queue',
                    'pass': r.count < 200,
                  }).toJSON()

  - name: APM Hub
    icon: logs
    properties:
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Backends count query
          query: SELECT count(*) FROM logging_backends WHERE deleted_at IS NULL
          results: 1
      name: Backends
    - configLookup:
        config:
          name: apm-hub
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: apm-hub
          type: Kubernetes::Deployment
        display:
          javascript: |
            config.spec.template.spec.containers[0]['image'].split(':')[1]
      headline: true
      name: Version
    - name: Docs
      text: https://docs.flanksource.com/apm-hub/overview
      type: url
    selectors:
    - labelSelector: app.kubernetes.io/name=apm-hub
    type: API
  - checks:
    - inline:
        http:
        - display: {}
          endpoint: http://config-db:8080/live
          name: config-db-http-check
          responseCodes:
          - 200
        schedule: '@every 1m'
    - inline:
        postgres:
          - query: |
              WITH cte AS (
                SELECT name, resource_id, resource_type, created_at, details, status, ROW_NUMBER() OVER (PARTITION by resource_id, name ORDER BY created_at DESC) AS rn
                FROM job_history
                WHERE
                  resource_id in (select id::text from config_scrapers where deleted_at is null) AND
                  status NOT IN ('RUNNING', 'ABORTED') AND
                  resource_type = 'config_scraper'
              )
              SELECT * FROM cte WHERE rn = 1
            connection: "connection://{{ .Values.connectionName }}"
            name: Config Scraper Checks
            transform:
              expr: |
                results.rows.map(r, {
                  'name': r.name + ':' + r.resource_id,
                  'icon': 'config',
                  'message': r.created_at + ' | ' + r.details.toJSON(),
                  'description': r.details.toJSON(),
                  'pass': r.status == 'SUCCESS' ,
                }).toJSON()

    components:
    - icon: k8s-customresourcedefinition
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: |
              JSON.stringify(results.rows.map(function(r) {return {
                name: r.name,
                properties: [
                {
                  name: 'Last runtime',
                  text: String(r.time_end),
                },
                {
                  name: 'Duration',
                  text: String(r.duration_millis),
                  unit: 'ms',
                  headline: true,
                },
                {
                  name: 'Success Count',
                  value: r.success_count,
                  headline: true,
                },
                {
                  name: 'Error Count',
                  value: r.error_count,
                  headline: true,
                },
              ],
              }}))
          name: Config scrapers count query
          query: |
            SELECT * FROM (
              SELECT
                ROW_NUMBER() OVER (PARTITION BY c.name ORDER BY time_end DESC) AS rn, c.name, jh.status, jh.success_count,
                jh.error_count, jh.duration_millis, jh.time_end
              FROM config_scrapers c
              INNER JOIN job_history jh ON c.id::text = jh.resource_id) AS s WHERE rn = 1
          results: 1
      name: ConfigScrapers
      type: lookup
    icon: config
    name: Config DB
    properties:
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Config Items count query
          query: SELECT count(*) FROM config_items WHERE deleted_at IS NULL
          results: 1
      name: Config Items
    - configLookup:
        config:
          name: config-db
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: config-db
          type: Kubernetes::Deployment
        display:
          javascript: |
            config.spec.template.spec.containers[0]['image'].split(':')[1]
      headline: true
      name: Version
    - name: Docs
      text: https://docs.flanksource.com/config-db/overview
      type: url
    selectors:
    - labelSelector: app.kubernetes.io/name=config-db
    type: API
  - icon: postgres
    name: PostgreSQL
    configs:
      - namespace: {{.Release.Namespace}}
        name: postgresql-0
        type: Kubernetes::Pod
    properties:
    - lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].version
          name: Version query
          query: SELECT VERSION()
          results: 1
          test: {}
          transform: {}
      name: Version
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].pg_size_pretty
          name: Size query
          query: SELECT pg_size_pretty(pg_database_size('mission_control'))
          results: 1
          test: {}
          transform: {}
      name: Size
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].sum
          name: Active connections query
          query: SELECT sum(numbackends) FROM pg_stat_database
          results: 1
      name: Connections
    selectors:
    - labelSelector: app=postgresql
      fieldSelector: namespace={{.Release.Namespace}}
    type: Database
  - icon: html
    name: UI
    properties:
    - configLookup:
        config:
          name: incident-manager-ui
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: incident-manager-ui
          type: Kubernetes::Deployment
        display:
          javascript: |
            config.spec.template.spec.containers[0]['image'].split(':')[1]
      headline: true
      name: Version
    selectors:
    - labelSelector: app.kubernetes.io/name=incident-manager-ui
    type: Website

  - name: Kratos
    icon: ory-kratos
    type: Service
    properties:
    - name: Version
      configLookup:
        config:
          name: kratos
          tags:
            app.kubernetes.io/instance: mission-control
            app.kubernetes.io/name: kratos
          type: Kubernetes::Deployment
        display:
          javascript: tags['app.kubernetes.io/version']
      headline: true
    - headline: true
      lookup:
        postgres:
        - connection: "connection://{{ .Values.connectionName }}"
          display:
            javascript: results.rows[0].count
          name: Count
          query: SELECT COUNT(*) FROM identities
          results: 1
      name: Identities
    selectors:
    - labelSelector: app.kubernetes.io/name=kratos

  - name: Jobs
    type: Jobs
    icon: clock
    components:
      - name: JobGroups
        lookup:
          postgres:
          - connection: "connection://{{ .Values.connectionName }}"
            query: |
              WITH ordered_history AS (
                SELECT
                  job_history.*,
                  ROW_NUMBER() OVER (PARTITION by name, resource_type, resource_id ORDER BY created_at DESC) AS rn
                FROM job_history
                WHERE status NOT IN ('RUNNING', 'ABORTED')
              )
              SELECT * from ordered_history where rn = 1 and resource_id = '';
            display:
              expr: |
                results.rows.map(r, {
                  'name': r.name,
                  'icon': 'clock',
                  'type': 'JobHistory',
                  'status': r.status in ['SUCCESS', 'FINISHED'] ? 'healthy': 'unhealthy',
                  'status_reason': r.status in ['SUCCESS', 'FINISHED'] ? '': r.details.toJSON(),
                  'properties': [
                    {'name': 'success_count', 'value': r.success_count, 'headline': true},
                    {'name': 'error_count', 'value': r.error_count, 'headline': true},
                    {'name': 'duration_ms', 'value': r.duration_millis},
                    {'name': 'last_run', 'text': string(r.time_end)},
                  ],
                }).toJSON()

  {{- if .Values.isAgent }}
  - name: Upstream Sync
    icon: helm
    properties:
      - name: Check Status Backlog
        lookup:
          postgres:
            - query: SELECT reltuples FROM  pg_class  WHERE relname ='check_statuses_is_pushed_idx'
              connection: "connection://{{ .Values.connectionName }}"
              display:
                expr: results.rows[0].reltuples
      - name: Config Analysis Backlog
        lookup:
          postgres:
            - query: SELECT count(*) FROM config_analysis where is_pushed is false
              connection: "connection://{{ .Values.connectionName }}"
              display:
                expr: results.rows[0].count
      - name: Config Changes Backlog
        lookup:
          postgres:
            - query: SELECT count(*) FROM config_changes where is_pushed is false
              connection: "connection://{{ .Values.connectionName }}"
              display:
                expr: results.rows[0].count
    checks:
      - inline:
          schedule: '@every 30s'
          postgres:
            - query: SELECT time_end FROM job_history WHERE name = 'ReconcileAll' AND status = 'SUCCESS' LIMIT 1
              connection: "connection://{{ .Values.connectionName }}"
              name: Last Full Reconcile
              display:
                expr: |
                  results.count == 0 ? 'N/A' : results.rows[0].time_end
              test:
                expr: |
                  results.count == 0 || time.Since(results.rows[0].time_end).getMinutes() > 2
      - inline:
          schedule: '@every 30s'
          postgres:
            - query: SELECT reltuples as count FROM  pg_class  WHERE relname ='check_statuses_is_pushed_idx'
              connection: "connection://{{ .Values.connectionName }}"
              name: Check Status Backlog
              display:
                expr: results.rows[0].count
              test:
                expr: results.rows[0].count < 500
      - inline:
          schedule: '@every 30s'
          postgres:
            - query: SELECT count(*) FROM config_analysis where is_pushed is false
              connection: "connection://{{ .Values.connectionName }}"
              name: Config Analysis Backlog
              display:
                expr: results.rows[0].count
              test:
                expr: results.rows[0].count < 200
      - inline:
          schedule: '@every 30s'
          postgres:
            - query: SELECT count(*) FROM config_changes where is_pushed is false
              connection: "connection://{{ .Values.connectionName }}"
              name: Config Changes Backlog
              display:
                expr: results.rows[0].count
              test:
                expr: results.rows[0].count < 200
  {{- end }}
